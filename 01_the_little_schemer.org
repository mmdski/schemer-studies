#+title: My Notes on The Little Schemer by Friedman and Felleisen
#+author: Marian Domanski
#+date: <2025-09-12 Fri 07:28>
#+startup: overview
* Introduction

Call org-babel-tangle (C-c C-v t is the default binding) to generate tls.scm.

#+begin_src scheme :tangle "tls.scm" :results none
  (define atom?
    (lambda (x)
      (and (not (pair? x)) (not (null? x)))))

  (define (sexp? x)
    (or (symbol?  x)
        (number?  x)
        (string?  x)
        (boolean? x)
        (null?    x)
        (and (pair? x)
             (sexp? (car x))
             (sexp? (cdr x)))))

#+end_src

* DONE Chapter 01: Toys
CLOSED: [2025-09-14 Sun 09:46]
:PROPERTIES:
:header-args:scheme: :session tls01
:END:

#+begin_src scheme :results none
  (load "tls.scm")
#+end_src

#+begin_src scheme
  (atom? 'atom)
#+end_src

#+RESULTS:
: #t

** The Law of Car
The primitive /car/ is defined only for non-empty lists.

** The Law of Cdr
The primitive /cdr/ is defined only for non-empty lists. The /cdr/ of any non-empty list is always another list.

** The Law of Cons
The primitive /cons/ takes two arguments. The second argument to /cons/ must be a list. The result is a list.

*** What is (cons s (car l)) where s is a and l is ((b) c d)?

#+begin_src scheme
  (cons 'a (car '((b) c d)))
#+end_src

#+RESULTS:
| a | b |

src_scheme{(cons 'a '((b) c d))} is src_scheme{'(a b)} because src_scheme{(car '((b) c d))} is src_scheme{'(b)} and src_scheme{(cons 'a '(b))} is src_scheme{'(a b)}.

** The Law of Null?
The primitive /null?/ is defined only for lists.

** The Law of Eq?
The primitive /eq?/ takes two arguments. Each must be a non-numeric atom.

* DONE Chapter 02: Do It, Do It Again, and Again, and Again...
CLOSED: [2025-09-14 Sun 19:48]
:PROPERTIES:
:header-args:scheme: :session tls02
:END:

#+begin_src scheme :tangle "tls.scm" :results none
  (define lat?
    (lambda (l)
      (cond
       ((null? l) #t)
       ((atom? (car l)) (lat? (cdr l)))
       (else #f))))

  (define member?
    (lambda (a lat)
      (cond
       ((null? lat) #f)
       (else (or (eq? (car lat) a)
                 (member? a (cdr lat)))))))
#+end_src

#+begin_src scheme :results none
    (load "tls.scm")
#+end_src

#+begin_src scheme
  (member? 'meat '(potatoes and meat gravy))
#+end_src

#+RESULTS:
: #t

#+begin_src scheme
  (member? 'liver '(bagels and lox))
#+end_src

#+RESULTS:
: #f

** The First Commandment
(/preliminary/)

Always ask /null?/ as the first question in expressing any function.

* DONE Chapter 03: Cons the Magnificent
CLOSED: [2025-09-29 Mon 19:23]
:PROPERTIES:
:header-args:scheme: :session tls03
:END:

#+begin_src scheme :results none
  (define rember
    (lambda (a lat)
      (cond
       ((null? lat) '())
       (else (cond
              ((eq? (car lat) a) (cdr lat))
              (else (rember a (cdr lat))))))))
#+end_src

#+begin_src scheme
  (rember 'bacon '(bacon lettuce and tomato))
#+end_src

#+RESULTS:
| lettuce | and | tomato |

#+begin_src scheme
  (rember 'and '(bacon lettuce and tomato))
#+end_src

#+RESULTS:
| tomato |

*The Second Commandment*
Use /cons/ to build lists.

#+begin_src scheme :results none
  (define rember
    (lambda (a lat)
      (cond
        ((null? lat) '())
        (else (cond
                ((eq? (car lat) a) (cdr lat))
                (else (cons (car lat)
                            (rember a (cdr lat)))))))))
#+end_src

#+begin_src scheme
  (rember 'and '(bacon lettuce and tomato))
#+end_src

#+RESULTS:
| bacon | lettuce | tomato |

#+begin_src scheme :results none
  (define rember
    (lambda (a lat)
      (cond
       ((null? lat) '())
       ((eq? (car lat) a) (cdr lat))
       (else (cons (car lat)
                   (rember a (cdr lat)))))))
#+end_src

#+begin_src scheme
  (rember 'and '(bacon lettuce and tomato))
#+end_src

#+RESULTS:
| bacon | lettuce | tomato |

*The Third Commandment*
When building a list, describe the first typical element, then /cons/ it onto the natural recursion.

#+begin_src scheme :tangle "tls.scm" :results none
  (define firsts
    (lambda (l)
      (cond
       ((null? l) '())
       (else (cons (car (car l))
                   (firsts (cdr l)))))))
#+end_src

#+begin_src scheme
  (firsts '((a b) (c d) (e f)))
#+end_src

#+RESULTS:
| a | c | e |

#+begin_src scheme
  (define insertR
    (lambda (new old lat)
      (cond
       ((null? lat) ('()))
       (else
        (cond
         ((eq? (car lat) old) (cdr lat))
         (else (cons (car lat)
                     (insertR new old
                              (cdr lat)))))))))
#+end_src

#+begin_src scheme
  (insertR 'topping 'fudge '(ice cream with fudge for dessert))
#+end_src

#+RESULTS:
| ice | cream | with | for | dessert |

#+begin_src scheme :results none
  (define insertR
    (lambda (new old lat)
      (cond
       ((null? lat) '())
       (else (cond
              ((eq? (car lat) old)
               (cons new (cdr lat)))
              (else (cons (car lat)
                          (insertR new old
                                   (cdr lat)))))))))
#+end_src

#+begin_src scheme
  (insertR 'topping 'fudge '(ice cream with fudge for dessert))
#+end_src

#+RESULTS:
| ice | cream | with | topping | for | dessert |

#+begin_src scheme :tangle "tls.scm" :results none
  (define insertR
    (lambda (new old lat)
      (cond
       ((null? lat) ('()))
       (else (cond
              ((eq? (car lat) old)
               (cons old
                     (cons new (cdr lat))))
              (else (cons (car lat)
                          (insertR new old
                                   (cdr lat)))))))))

#+end_src

#+begin_src scheme
  (insertR 'topping 'fudge '(ice cream with fudge for dessert))
#+end_src

#+RESULTS:
| ice | cream | with | fudge | topping | for | dessert |

#+begin_src scheme :tangle "tls.scm" :results none
  (define insertL
    (lambda (new old lat)
      (cond
       ((null? lat) ('()))
       (else (cond
              ((eq? (car lat) old)
               (cons new lat))
              (else (cons (car lat)
                          (insertL new old
                                   (cdr lat)))))))))

#+end_src

#+begin_src scheme :tangle "tls.scm" :results none
  (define subst
    (lambda (new old lat)
      (cond
       ((null? lat) ('()))
       (else (cond
              ((eq? (car lat) old)
               (cons new (cdr lat)))
              (else (cons (car lat)
                          (subst new old
                                   (cdr lat)))))))))

#+end_src

#+begin_src scheme :tangle "tls.scm" :results none
  (define subst2
    (lambda (new o1 o2 lat)
      (cond
       ((null? lat) ('()))
       (else (cond
              ((or (eq? (car lat) o1) (eq? (car lat) o2))
               (cons new (cdr lat)))
              (else (cons (car lat)
                          (subst new old
                                 (cdr lat)))))))))

#+end_src

#+begin_src scheme :tangle "tls.scm" :results none
  (define multirember
    (lambda (a lat)
      (cond
       ((null? lat) '())
       (else
        (cond
         ((eq? (car lat) a)
          (multirember a (cdr lat)))
         (else (cons (car lat)
                     (multirember a
                                  (cdr lat)))))))))
#+end_src

#+begin_src scheme :tangle "tls.scm" :results none
  (define multiinsertR
    (lambda (new old lat)
      (cond
       ((null? lat) ('()))
       (else
        (cond
         ((eq? (car lat) old)
          (cons (car lat)
                (cons new
                      (multiinsertR new old
                                    (cdr lat)))))
         (else (cons (car lat)
                     (multiinsertR new old
                                   (cdr lat)))))))))
#+end_src

* DONE Chapter 04: Numbers Games
CLOSED: [2025-10-10 Fri 14:55]
:PROPERTIES:
:header-args:scheme: :session tls04
:END:

#+begin_src scheme
  (add1 67)
#+end_src

#+RESULTS:
: 68

#+begin_src scheme
  (sub1 5)
#+end_src

#+RESULTS:
: 4

#+begin_src scheme
  (sub1 0)
#+end_src

#+RESULTS:
: -1

#+begin_src scheme :tangle "tls.scm" :results none
  (define o+
    (lambda (n m)
      (cond
       ((zero? m) n)
       (else (add1 (o+ n (sub1 m)))))))

  (define o-
    (lambda (n m)
      (cond
       ((zero? m) n)
       (else (sub1 (o- n (sub1 m)))))))
       #+end_src

*The First Commandment*
(/first revision/)
When recurring on a list of atoms, /lat/, ask two questions about it: (/null? lat/) and else.
When recurring on a number, /n/, ask two questions about it: (/zero? n/) and else.

#+begin_src scheme
  (define addtup
    (lambda (tup)
      (cond
       ((null? tup) 0)
       (else (o+ (car tup) (addtup (cdr tup)))))))
#+end_src

#+begin_src scheme :tangle "tls.scm" :results none
  (define o*
    (lambda (n m)
      (cond
       ((zero? m) 0)
       (else (o+ n (o* n (sub1 m)))))))
#+end_src

#+begin_src scheme :tangle "tls.scm" :results none
  (define tup+
    (lambda (tup1 tup2)
      (cond
       ((null? tup1) tup2)
       ((null? tup2) tup1)
       (else
        (cons (o+ (car tup1) (car tup2))
              (tup+ (cdr tup1) (cdr tup2)))))))
#+end_src

#+begin_src scheme :results none
  (define >
    (lambda (n m)
      (cond
       ((zero? m) #t)
       ((zero? n) #f)
       (else (> (sub1 n) (sub1 m))))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define >
    (lambda (n m)
      (cond
       ((zero? n) #f)
       ((zero? m) #t)
       (else (> (sub1 n) (sub1 m))))))
    #+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define <
    (lambda (n m)
      (cond
       ((zero? m) #f)
       ((zero? n) #t)
       (else (< (sub1 n) (sub1 m))))))
#+end_src

#+begin_src scheme :results none
  (define =
    (lambda (n m)
      (cond
       ((zero? m) (zero? n))
       ((zero? n) #f)
       (else (= (sub1 n) (sub1 m))))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define =
    (lambda (n m)
      (cond
       ((> n m) #f)
       ((< n m) #f)
       (else #t))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define expt
    (lambda (n m)
      (cond
       ((zero? m 0) 1)
       (else (o* n (expt n (sub1 m)))))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define quotient
    (lambda (n m)
      (cond
       ((< n m) 0)
       (else (add1 (quotient (- n m) m))))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define length
    (lambda (lat)
      (cond
       ((null? lat) 0)
       (else (add1 (length (cdr lat)))))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define pick
    (lambda (n lat)
      (cond
       ((zero? (sub1 n)) (car lat))
       (else (pick (sub1 n) (cdr lat))))))
#+end_src

#+begin_src scheme :results none
  (define rempick
    (lambda (n lat)
      (cond
       ((zero? (sub1 n)) (cdr lat))
       (else (cons (car lat) (rempick (sub1 n) (cdr lat)))))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define no-nums
    (lambda (lat)
      (cond
       ((null? lat) '())
       ((number? (car lat)) (no-nums (cdr lat)))
       (else (cons (car lat) (no-nums (cdr lat)))))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define all-nums
    (lambda (lat)
      (cond
       ((null? lat) '())
       ((number? (car lat)) (cons (car lat) (all-nums (cdr lat))))
       (else (all-nums (cdr lat))))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define eqan?
    (lambda (a1 a2)
      (cond
       ((and (number? a1) (number? a2)) (= a1 a2))
       ((or (number? a1) (number? a2)) #f)
       (else (eq? a1 a2)))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define occur
    (lambda (a lat)
      (cond
       ((null? lat) 0)
       (else
        (cond
         ((eq? (car lat) a)
          (add1 (occur a (cdr lat))))
         (else (occur a (cdr lat))))))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define one?
    (lambda (n)
      (= n 1)))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define rempick
    (lambda (n lat)
      (cond
       ((one? n) (cdr lat))
       (else (cons (car lat) (rempick (sub1 n) (cdr lat)))))))
#+end_src

* DONE Chapter 05: =*Oh My Gawd*=: It's Full of Stars
CLOSED: [2025-10-12 Sun 21:01]
:PROPERTIES:
:header-args:scheme: :session tls05
:END:
#+begin_src scheme :results none :tangle "tls.scm"
  (define rember*
    (lambda (a l)
      (cond
       ((null? l) '())
       ((atom? (car l))
        (cond
         ((eq? (car l) a)
          (rember* a (cdr l)))
         (else (cons (car l)
                     (rember* a (cdr l))))))
       (else (cons (rember* a (car l))
                   (rember* a (cdr l)))))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define insertR*
    (lambda (new old l)
      (cond
       ((null? l) '())
       ((atom? (car l))
        (cond
         ((eq? (car l) old)
          (cons old (cons new (insertR* new old (cdr l)))))
         (else (cons (car l)
                     (insertR* new old (cdr l))))))
       (else (cons (insertR* new old (car l))
                   (insertR* new old (cdr l)))))))
#+end_src

*The First Commandment*
(/final version/)
When recurring on a list of atoms, /lat/, ask two questions about it: (/null? lat/) and else.
When recurring on a number, /n/, ask two questions about it: (/zero? n/) and else.
When recurring on a list of S-expressions, /l/, ask three questions about it: (/null? l/), (/atom?/ (/car l/)), and else.

*The Fourth Commandment*
(/final version/)
Always change at least one argument while recurring. When recurring on a list of atoms, /lat/, use (/cdr lat/). When recurring on a number, /n/, use (/sub1 n/). And when recurring on a list of S-expressions, /l/, use (/car l/) and (/cdr l/) if neither (/null? l/) nor (/atom?/ (/car l/)) are true.

It must be changed to be close to termination. The changing argument must be tested in the termination conditions:

when using /cdr/, test termination with /null?/ and when using /sub1/, test termination with /zero?/.

#+begin_src scheme :results none :tangle "tls.scm"
  (define occur*
    (lambda (a l)
      (cond
       ((null? l) 0)
       ((atom? (car l))
        (cond
         ((eq? (car l) a)
          (add1 (occur* a (cdr l))))
         (else (occur* a (cdr l)))))
       (else (o+ (occur* a (car l)) (occur* a (cdr l)))))))
#+end_src

#+begin_src scheme
  (occur* 'banana
          '((banana)
            (split ((((banana ice)))
                    (cream (banana))
                    sherbert))
            (banana)
            (bread)
            (banana brandy)))
#+end_src

#+RESULTS:
: 5

#+begin_src scheme :results none :tangle "tls.scm"
  (define subst*
    (lambda (new old l)
      (cond
       ((null? l) '())
       ((atom? (car l))
        (cond
         ((eq? (car l) old)
          (cons new (subst* new old (cdr l))))
         (else (cons (car l) (subst* new old (cdr l))))))
        (else
         (cons (subst* new old (car l)) (subst* new old (cdr l)))))))
#+end_src

#+begin_src scheme :results verbatim
  (subst* 'orange 'banana
          '((banana)
            (split ((((banana ice)))
                    (cream (banana))
                    sherbert))
            (banana)
            (bread)
            (banana brandy)))
#+end_src

#+RESULTS:
: ((orange) (split ((((orange ice))) (cream (orange)) sherbert)) (orange) (bread) (orange brandy))

#+begin_src scheme :results none
  (define insertL*
    (lambda (new old l)
      (cond
       ((null? l) '())
       ((atom? (car l))
        (cond
         ((eq? old (car l))
          (cons new (cons old
                          (insertL* new old (cdr l)))))
         (else
          (cons (car l) (insertL* new old (cdr l))))))
       (else
        (cons (insertL* new old (car l))
              (insertL* new old (cdr l)))))))
              #+end_src

#+begin_src scheme :results verbatim
  (insertL* 'pecker 'chuck
            '((how much (wood))
              could
              ((a (wood) chuck))
              (((chuck)))
              (if (a) ((wood chuck)))
              could chuck wood))
#+end_src

#+RESULTS:
: ((how much (wood)) could ((a (wood) pecker chuck)) (((pecker chuck))) (if (a) ((wood pecker chuck))) could pecker chuck wood)

#+begin_src scheme :results none
  (define member*
    (lambda (a l)
      (cond
       ((null? l) #f)
       ((atom? (car l))
        (or (eq? (car l) a)
            (member* a (cdr l))))
       (else
        (or (member* a (car l))
            (member* a (cdr l)))))))
#+end_src

#+begin_src scheme :results verbatim
  (member* 'chips
           '((potato) (chips ((with) fish) (chips))))
#+end_src

#+RESULTS:
: #t

#+begin_src scheme :results none :tangle "tls.scm"
  (define leftmost
    (lambda (l)
      (cond
       ((atom? (car l)) (car l))
       (else (leftmost (car l))))))
#+end_src

#+begin_src scheme :results verbatim
  (leftmost
   '((potato) (chips ((with) fish) (chips))))
#+end_src

#+RESULTS:
: potato

#+begin_src scheme :results verbatim
  (leftmost
   '(((hot) (tuna (and))) cheese))
#+end_src

#+RESULTS:
: hot

#+begin_src scheme :results none
  (define eqlist?
    (lambda (l1 l2)
      (cond
       ((and (null? l1) (null? l2)) #t)
       ((or (null? l1) (null? l2)) #f)
       ((and (atom? (car l1)) (atom? (car l2)))
        (and (eqan? (car l1) (car l2)) (eqlist? (cdr l1) (cdr l2))))
       ((or (atom? (car l1)) (atom? (car l2))) #f)
       (else
        (and (eqlist? (car l1) (car l2))
             (eqlist? (cdr l1) (cdr l2)))))))
#+end_src

#+begin_src scheme :results verbatim
  (eqlist? '(strawberry ice cream) '(strawberry cream ice))
#+end_src

#+RESULTS:
: #f

#+begin_src scheme :results verbatim
  (eqlist? '(beef ((sausage)) (and (soda)))
           '(beef ((sausage)) (and (soda))))
#+end_src

#+RESULTS:
: #t

#+begin_src scheme :results none :tangle "tls.scm"
  (define equal?
    (lambda (s1 s2)
      (cond
       ((and (atom? s1) (atom? s2))
        (eqan? s1 s2))
       ((or (atom? s1) (atom? s2)) #f)
       (else (eqlist? s1 s2)))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define eqlist?
    (lambda (l1 l2)
      (cond
       ((and (null? l1) (null? l2)) #t)
       ((or (null? l1) (null? l2)) #f)
       (else
        (and (equal? (car l1) (car l2))
             (eqlist? (cdr l1) (cdr l2)))))))
#+end_src

*The Sixth Commandment*
Simplify only after the function is correct.

#+begin_src scheme :results none :tangle "tls.scm"
  (define rember
    (lambda (s l)
      (cond
       ((null? l) '())
       ((equal? (car l) s) (cdr l))
       (else (cons (car l)
                   (rember s (cdr l)))))))
#+end_src

* DONE Chapter 06: Shadows
CLOSED: [2025-10-26 Sun 19:34]
:PROPERTIES:
:header-args:scheme: :session tls06
:END:

#+begin_src scheme :results none :tangle "tls.scm"
  (define numbered?
    (lambda (aexp)
      (cond
       ((atom? aexp) (number? aexp))
       (else
        (and (numbered? (car aexp))
             (numbered?
              (car (cdr (cdr aexp)))))))))
#+end_src

#+begin_src scheme :results none
  (define value
    (lambda (nexp)
      (cond
       ((atom? nexp) nexp)
       ((eq? (car nexp) '+)
        (o+ (value (cdr nexp))
            (value (cdr (cdr nexp)))))
       ((eq? (car nexp) '*)
        (o* (value (cdr nexp))
            (value (cdr (cdr nexp)))))
       (else
        (exp (value (cdr nexp))
             (value (cdr (cdr nexp))))))))
#+end_src

#+begin_src scheme :results none :tangle "tls.scm"
  (define 1st-sub-exp
    (lambda (aexp)
      (car (cdr aexp))))

  (define 2nd-sub-exp
    (lambda (aexp)
      (car (cdr (cdr aexp)))))

  (define operator
    (lambda (aexp)
      (car aexp)))

  (define value
    (lambda (nexp)
      (cond
       ((atom? nexp) nexp)
       ((eq? (operator nexp) '+)
        (o+ (value (1st-sub-exp nexp))
            (value (2nd-sub-exp nexp))))
       ((eq? (operator nexp) '*)
        (o* (value (1st-sub-exp nexp))
            (value (2nd-sub-exp nexp))))
       (else
        (expt (value (1st-sub-exp nexp))
              (value (2nd-sub-exp nexp)))))))
#+end_src

* TODO Chapter 07: Friends and Relations
:PROPERTIES:
:header-args:scheme: :session tls07
:END:
